spending CommunityTreasury

// needed in helios 0.13: defaults
const mph : MintingPolicyHash = MintingPolicyHash::new(#1234)

enum Datum {
    CharterToken {
        trustees: []Address
        minSigs: Int
    }
}

enum Redeemer {
    foo
    bar
    charterMint
    authorizeByCharter
    authorizeTreasuryMint {
        tokenName: String
    }
}


func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    // now: Time = tx.time_range.start;
    
    tt : Bool = redeemer.switch {
        foo => { true },
        bar => { true },
        charterMint => {
            // charterTokenOut : TxOutput = tx.outputs.find(isCharterToken);
            // if (!charterToken) { error("missing required charter token deposit during charterMint") };

            // if (charterToken.address != 
            // trustees.all( ( t : Address) -> Bool {
            //     // c: Credential = t.credential;
            //     // Credential::PubKey{hash} = c;
            //     t.credential.switch{
            //         pubKey: PubKey => {
            //             tx.is_signed_by(pubKey.hash)
            //         },
            //         // contract:
            //          Validator => {
            //             error("invalid address in initialTrustees list: can't expect a contract addr to sign a transaction")

            //             // tx.is_signed_by(contract.hash)
            //         },
            //         _ => false
            //     }                
            // })
            // print(hash.show());
            true
        },
        authorizeByCharter => {            
            charterTokenValue : Value = Value::new(
                AssetClass::new(mph, "charter".encode_utf8()), 
                1
            );
            myself : Credential = Credential::new_validator(ctx.get_current_validator_hash());
            
            assert(tx.outputs.any((txo : TxOutput) -> Bool {
                txo.value >= charterTokenValue
            }),"missing required 'charter' token authorization");

            assert(tx.outputs.any((txo : TxOutput) -> Bool {
                txo.value >= charterTokenValue &&
                txo.address.credential == myself
            }),  "charter token must be returned to the contract");

            true
        },
        x: authorizeTreasuryMint => {
            //! guards from optimizing mph out of the program, screwing up parameterization
            mph.serialize() != datum.serialize() &&

            // !initialTrustees.is_empty() &&
            // initialTrustees.head != initialTrustees.head &&
            x.tokenName == x.tokenName 
            // now < datum.deadline &&
            // tx.is_signed_by(datum.creator)
        }
    };

    tt &&
    tx.serialize() != datum.serialize()
}

const charterTokenBaseInfo: Datum::CharterToken = Datum::CharterToken{
    trustees: []Address{},
    minSigs: 1
}

// const mkCharterTokenDatum : (trustees: []Address, minSigs: Int) -> Datum::CharterSeed = (trustees: []Address, minSigs: Int) -> Datum::CharterSeed {
//      Datum::CharterToken{
//         nce: nce(),
//         trustees: trustees,
//         minSigs: minSigs
//     }
// }
