spending CommunityTreasury

// needed in helios 0.13: defaults
const mph : MintingPolicyHash = MintingPolicyHash::new(#1234)

enum Datum {
    CharterToken {
        trustees: []Address
        minSigs: Int
    }
}

enum Redeemer {
    foo
    updateCharter{
        trustees: []Address
        minSigs: Int
    }
    charterMint
    authorizeByCharter
    tokenMint {
        tokenName: String
    }
}


func requiresAuthorization(ctx: ScriptContext, datum: Datum, newDatum: Datum::CharterToken) -> Bool {
    Datum::CharterToken{trustees, minSigs} = datum;
    tx : Tx = ctx.tx;

    charterTokenValue : Value = Value::new(
        AssetClass::new(mph, "charter".encode_utf8()), 
        1
    );

    foundSigs: Int = trustees.fold[Int](
        (count: Int, a: Address) -> Int {
            trusteePkh : PubKeyHash = a.credential.switch{
                PubKey{h} => h,
                _ => error("trustee can't be a contract")
            };
            print("checking if trustee signed: " + trusteePkh.show());

            count + if (tx.is_signed_by(trusteePkh)) {1} else {0}
        }, 0
    );
    assert(foundSigs >= minSigs, 
        "not enough trustees ("+foundSigs.show()+ " of " + minSigs.show() + " needed) have signed the tx" 
    );

    charterOutput : TxOutput = tx.outputs.find_safe(
        (txo : TxOutput) -> Bool {
            txo.value >= charterTokenValue
        }
    ).switch{
        None => error("this could only happen if the charter token is burned."),
        Some{o} => o
    };
    
    cvh : ValidatorHash = ctx.get_current_validator_hash();
    myself : Credential = Credential::new_validator(cvh);
    if (charterOutput.address.credential != myself) {
        actual : String = charterOutput.address.credential.switch{
            PubKey{pkh} => "pkh:ðŸ”‘#" + pkh.show(),
            Validator{vh} => "val:ðŸ“œ#:" + vh.show()
        };
        error(
            "charter token must be returned to the contract " + cvh.show() +
            "... but was sent to " +actual
        )
    };

    Datum::CharterToken{newTrustees, newMinSigs} = Datum::from_data( 
        charterOutput.datum.get_inline_data() 
    );

    if ( !(
        charterOutput.value >= charterTokenValue &&
        newTrustees == newDatum.trustees &&
        newMinSigs == newDatum.minSigs
    )) { 
        error("invalid update to charter settings") 
    };

    true
}

func requiresProofOfNewTrustees(
    // ctx: ScriptContext
) -> Bool {
    if (false) { error("needs impl: requiresProofOfNewTrustees") };

    false
}


func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    // now: Time = tx.time_range.start;
    
    tt : Bool = redeemer.switch {
        foo => { true },
        updateCharter{trustees, minSigs} => { 
            assert(mph.serialize() != datum.serialize(), "guard failed"); // can't fail.
            newDatum : Datum::CharterToken = Datum::CharterToken{trustees, minSigs};
            //!!! todo: requires ALL of the NEW trustees to sign, regardless of minSigs.
            requiresProofOfNewTrustees(/*ctx*/) &&
            requiresAuthorization(ctx, datum, newDatum)
        },
        charterMint => {
            // charterTokenOut : TxOutput = tx.outputs.find(isCharterToken);
            // if (!charterToken) { error("missing required charter token deposit during charterMint") };

            // if (charterToken.address != 
            // trustees.all( ( t : Address) -> Bool {
            //     // c: Credential = t.credential;
            //     // Credential::PubKey{hash} = c;
            //     t.credential.switch{
            //         pubKey: PubKey => {
            //             tx.is_signed_by(pubKey.hash)
            //         },
            //         // contract:
            //          Validator => {
            //             error("invalid address in initialTrustees list: can't expect a contract addr to sign a transaction")

            //             // tx.is_signed_by(contract.hash)
            //         },
            //         _ => false
            //     }                
            // })
            // print(hash.show());
            true
        },
        // authorizeByCharter{otherRedeemerData, otherSignatures} => {            
        //     false // todo support authorizing **other** things to be done with this token
        // },
        authorizeByCharter => {
            assert(mph.serialize() != datum.serialize(), "guard failed"); // can't fail.

            requiresAuthorization(ctx, datum, datum.switch{x: CharterToken => x})
        },
        tokenMint{tokenName} => {
            //! guards from optimizing mph out of the program, screwing up parameterization
            assert(mph.serialize() != datum.serialize(), "guard failed"); // can't fail.
            tokenName == tokenName  &&
            requiresAuthorization(ctx, datum, datum.switch{x: CharterToken => x})

            // findCharter : Option[TxInput] = tx.inputs.find_safe( (txi : TxInput) -> Bool {
            //     txi.output.value >= charterTokenValue
            // });
            // charterInput : TxInput = findCharter.switch{
            //     Some{i} => i,
            //     _ => error("missing required authorization token")
            // };
            
            // !initialTrustees.is_empty() &&
            // initialTrustees.head != initialTrustees.head &&
            // now < datum.deadline &&
            // tx.is_signed_by(datum.creator)
        }
    };

    tt &&
    tx.serialize() != datum.serialize()
}

const charterTokenBaseInfo: Datum::CharterToken = Datum::CharterToken{
    trustees: []Address{},
    minSigs: 1
}

// const mkCharterTokenDatum : (trustees: []Address, minSigs: Int) -> Datum::CharterSeed = (trustees: []Address, minSigs: Int) -> Datum::CharterSeed {
//      Datum::CharterToken{
//         nce: nce(),
//         trustees: trustees,
//         minSigs: minSigs
//     }
// }
