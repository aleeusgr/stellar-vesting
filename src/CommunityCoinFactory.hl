minting coinFactory

const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42

enum Redeemer { 
    mintingCharterToken {
        treasury: Address
    }
    mintingNamedToken
    burningToken
}

func hasSeedUtxo(tx: Tx) -> Bool {
    seedUtxo: TxOutputId = TxOutputId::new(
        seedTxn,
        seedIndex
    );
    assert(tx.inputs.any( (input: TxInput) -> Bool {
        input.output_id == seedUtxo
    }),  "seed utxo required for minting the charter token");

    true
}

func main(r : Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    value_minted: Value = tx.minted;

    charterToken: AssetClass = AssetClass::new(
        mph,
        "charter".encode_utf8()
    );
    
    //!!! todo: fails if minSigs < trustees.length in datum of charter
    //    If this isn't enforced, then it's possible to create a charter that
    //    can never do anything.  That might be low impact, or it might
    //    result in a loss of fees & stake needed tor chartering a treasury.

    ok : Bool = r.switch {
        charter: mintingCharterToken => {       
            assert(value_minted == Value::new(charterToken, 1), "no charter token minted");

            hasSeedUtxo(tx) &&
            tx.outputs.all( (output: TxOutput) -> Bool {
                output.value != value_minted || (
                    output.value == value_minted &&
                    output.address == charter.treasury
                )
            })
        },
        mintingNamedToken => {
            charterTokenValue : Value = Value::new(
                AssetClass::new(ctx.get_current_minting_policy_hash(), "charter".encode_utf8()), 
                1
            );
            
            assert(tx.outputs.any((txo : TxOutput) -> Bool {
                txo.value >= charterTokenValue
            }),"missing required charter token authorization");

            // fooToken: AssetClass = AssetClass::new(
            //     ctx.get_current_minting_policy_hash(),
            //     tx.output.any((input: TxInput) -> Bool {
            //         tokenName: string = input.x.y
            //         tokenName.encode_utf8()
            //     }
            // );
        

            // tx.inputs
            //     .any((input: TxInput) -> Bool {
            //         print ("inp: "+ input.serialize().show() );
            //         foundCharter : Int = input.value.get_safe(charterToken);

            //         1 == foundCharter
            //     })
true    
        },
        burningToken => {
            false
        },
        _ => true
    };

    print("coin factory: minting value: " + value_minted.show());

    ok
}

