minting tokenVendingMachine

// const TREASURY_CONTRACT : Address = ""
const seedTxn : TxId = TxId::new(#1234)
const index : Int = 42
// const OWNER: Address = ""

enum Redeemer { 
    Charter {
        treasury: Address
    }
    Mint {
        tokenName: String
    }
    Burn
}

func main(r : Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();
    value_minted: Value = tx.minted;

    charterToken: AssetClass = AssetClass::new(
        ctx.get_current_minting_policy_hash(),
        "charter".encode_utf8()
    );


    ok : Bool = r.switch {
        c: Charter => {
            outputId: TxOutputId = TxOutputId::new(
                seedTxn,
                index
            );

            value_minted == Value::new(charterToken, 1) &&
            tx.inputs.any( (input: TxInput) -> Bool {
                input.output_id == outputId
            }) &&
            tx.outputs.all( (output: TxOutput) -> Bool {
                output.address == c.treasury
            })
        },
        Mint => {
            // fooToken: AssetClass = AssetClass::new(
            //     ctx.get_current_minting_policy_hash(),
            //     tx.output.any((input: TxInput) -> Bool {
            //         tokenName: string = input.x.y
            //         tokenName.encode_utf8()
            //     }
            // );
        
            // tx.inputs
            //     .any((input: TxInput) -> Bool {
            //         print ("inp: "+ input.serialize().show() );
            //         foundCharter : Int = input.value.get_safe(charterToken);

            //         1 == foundCharter
            //     })
true    
        },
        Burn => {
            true
        },
        _ => true
    };

    expectedCoin: AssetClass = AssetClass::new(
        mph, 
        "REP".encode_utf8()
    );

    ok &&
    (value_minted == Value::new(expectedCoin, 1)).trace("minted 1 ok!")
}

